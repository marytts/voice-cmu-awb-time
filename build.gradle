buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath("de.dfki.mary:marytts-builder:5.2") {
            exclude group: '*', module: 'groovy-all'
            exclude group: '*', module: 'mwdumper'
            exclude group: '*', module: 'sgt'
        }
    }
}

plugins {
    id 'de.dfki.mary.voicebuilding-legacy'
    id 'de.dfki.mary.voicebuilding-festvox'
}

group 'de.dfki.mary'
version '5.3-SNAPSHOT'

marytts.voice {
    name = 'cmu-awb-time'
    language = 'en'
    region = 'US'
    gender = 'male'
    type = 'unit selection'
    description = 'A male Scottish English limited-domain unit selection voice, built from recordings provided by Carnegie Mellon University'
    samplingRate = 16000
}

repositories {
    ivy {
        url 'https://dl.bintray.com/marytts/marytts'
        layout 'pattern', {
            artifact '[organisation]/[module]/[artifact].[ext]'
        }
    }
    ivy {
        url 'http://festvox.org/examples'
        layout 'pattern', {
            artifact '[module]_[classifier]/packed/[artifact].[ext]'
        }
    }
}

dependencies {
    data group: 'org.festvox', name: 'cmu_time_awb', classifier: 'ldom', ext: 'tar.bz2'
}

text {
    srcFile = file("$sourceSets.data.output.resourcesDir/time.data")
}

basenames {
    textDir = text.destDir
    labDir = lab.destDir
}

generateAllophones {
    srcDir = text.destDir
}

generateVoiceConfig {
    afterEvaluate {
        config.get() << [
                exampleTextFile: "jar:/marytts/voice/$marytts.voice.nameCamelCase/exampleText.txt",
        ]
    }
}

task makeBasenameDatagrams(type: MakeBasenameDatagrams) {
    basenamesFile = basenames.destFile
    sampleRate = marytts.voice.samplingRate
    pmDir = pitchmarkConverter.destDir
    destDir = layout.buildDirectory.dir('basenameDatagrams')
}

task basenameTimelineMaker(type: TimelineMaker) {
    basenamesFile = basenames.destFile
    sampleRate = marytts.voice.samplingRate
    idxIntervalInSeconds = 2.0
    srcDir = makeBasenameDatagrams.destDir
    destFile = layout.buildDirectory.file('timeline_basenames.mry')
}

task testBasenameTimelineMaker {
    dependsOn basenameTimelineMaker, legacyBasenameTimelineMaker
    doLast {
        def actual = basenameTimelineMaker.destFile.get().asFile.bytes
        def expected = legacyBasenameTimelineMaker.destFile.get().asFile.bytes
        assert actual == expected
    }
}

task makeWaveDatagrams(type: MakeWaveDatagrams) {
    basenamesFile = basenames.destFile
    sampleRate = marytts.voice.samplingRate
    wavDir = wav.destDir
    pmDir = pitchmarkConverter.destDir
    destDir = layout.buildDirectory.dir('waveDatagrams')
}

task waveTimelineMaker(type: TimelineMaker) {
    basenamesFile = basenames.destFile
    sampleRate = marytts.voice.samplingRate
    idxIntervalInSeconds = 0.1
    srcDir = makeWaveDatagrams.destDir
    destFile = layout.buildDirectory.file('timeline_waveforms.mry')
}

task testWaveTimelineMaker {
    dependsOn waveTimelineMaker, legacyWaveTimelineMaker
    doLast {
        def actual = waveTimelineMaker.destFile.get().asFile.bytes
        def expected = legacyWaveTimelineMaker.destFile.get().asFile.bytes
        assert actual == expected
    }
}

task makeMcepDatagrams(type: MakeMcepDatagrams) {
    basenamesFile = basenames.destFile
    sampleRate = marytts.voice.samplingRate
    mcepDir = mcepExtractor.destDir
    destDir = layout.buildDirectory.dir('mcepDatagrams')
}

task generateMcepTimelineHeader(type: GenerateMcepTimelineHeader) {
    srcDir = mcepExtractor.destDir
    destFile = layout.buildDirectory.file('timeline_mcep.properties')
}

task mcepTimelineMaker(type: McepTimelineMaker) {
    basenamesFile = basenames.destFile
    headerFile = generateMcepTimelineHeader.destFile
    sampleRate = marytts.voice.samplingRate
    idxIntervalInSeconds = 0.1
    srcDir = makeMcepDatagrams.destDir
    destFile = layout.buildDirectory.file('timeline_mcep.mry')
}

task testMcepTimelineMaker {
    dependsOn mcepTimelineMaker, legacyMCepTimelineMaker
    doLast {
        def actual = mcepTimelineMaker.destFile.get().asFile.bytes
        def expected = legacyMCepTimelineMaker.destFile.get().asFile.bytes
        assert actual == expected
    }
}

import groovy.json.JsonBuilder
import groovy.json.JsonSlurper
import marytts.tools.voiceimport.TimelineWriter
import marytts.tools.voiceimport.WavReader
import marytts.unitselection.data.MCepDatagram
import marytts.util.data.Datagram
import marytts.util.data.ESTTrackReader

import javax.inject.Inject

class MakeBasenameDatagrams extends DefaultTask {

    final WorkerExecutor workerExecutor

    @Input
    Property<Integer> sampleRate = project.objects.property(Integer)

    @InputFile
    final RegularFileProperty basenamesFile = newInputFile()

    @InputDirectory
    final DirectoryProperty pmDir = newInputDirectory()

    @OutputDirectory
    final DirectoryProperty destDir = newOutputDirectory()

    @Inject
    MakeBasenameDatagrams(WorkerExecutor workerExecutor) {
        this.workerExecutor = workerExecutor
    }

    @TaskAction
    void make() {
        basenamesFile.get().asFile.eachLine('UTF-8') { basename ->
            def pmFile = pmDir.file("${basename}.pm").get().asFile
            def destFile = destDir.file("${basename}.json").get().asFile
            workerExecutor.submit(BasenameDatagramMaker.class) { config ->
                config.params pmFile, destFile, sampleRate.get()
            }
        }
    }
}

class BasenameDatagramMaker implements Runnable {

    File pmFile

    File destFile

    int sampleRate

    @Inject
    BasenameDatagramMaker(File pmFile, File destFile, int sampleRate) {
        this.pmFile = pmFile
        this.destFile = destFile
        this.sampleRate = sampleRate
    }

    @Override
    void run() {
        def lastTime = pmFile.readLines().last().split().first() as float
        def duration = (lastTime * sampleRate) as long
        def basename = pmFile.name - '.pm'
        def json = new JsonBuilder([
                [
                        duration: duration,
                        data    : basename.bytes.encodeBase64().toString()
                ]
        ])
        destFile.text = json
    }
}

class MakeWaveDatagrams extends DefaultTask {

    final WorkerExecutor workerExecutor

    @Input
    Property<Integer> sampleRate = project.objects.property(Integer)

    @InputFile
    final RegularFileProperty basenamesFile = newInputFile()

    @InputDirectory
    final DirectoryProperty wavDir = newInputDirectory()

    @InputDirectory
    final DirectoryProperty pmDir = newInputDirectory()

    @OutputDirectory
    final DirectoryProperty destDir = newOutputDirectory()

    @Inject
    MakeWaveDatagrams(WorkerExecutor workerExecutor) {
        this.workerExecutor = workerExecutor
    }

    @TaskAction
    void make() {
        basenamesFile.get().asFile.eachLine('UTF-8') { basename ->
            def wavFile = wavDir.file("${basename}.wav").get().asFile
            def pmFile = pmDir.file("${basename}.pm").get().asFile
            def destFile = destDir.file("${basename}.json").get().asFile
            workerExecutor.submit(WaveDatagramMaker.class) { config ->
                config.params wavFile, pmFile, destFile, sampleRate.get()
            }
        }
    }

}

class WaveDatagramMaker implements Runnable {

    File wavFile

    File pmFile

    File destFile

    int sampleRate

    @Inject
    WaveDatagramMaker(File wavFile, File pmFile, File destFile, int sampleRate) {
        this.wavFile = wavFile
        this.pmFile = pmFile
        this.destFile = destFile
        this.sampleRate = sampleRate
    }

    @Override
    void run() {
        def pm = new ESTTrackReader(pmFile.path)
        def wav = new WavReader(wavFile.path)
        def wave = wav.samples
        def jsonDatagrams = []
        int frameStart
        int frameEnd = 0
        pm.times.each { time ->
            frameStart = frameEnd
            frameEnd = (time * sampleRate) as int
            def duration = frameEnd - frameStart
            def baos = new ByteArrayOutputStream(2 * duration)
            def dos = new DataOutputStream(baos)
            if (duration > 0) {
                (frameStart..frameEnd - 1).each { f ->
                    dos.writeShort wave[f]
                }
            }
            jsonDatagrams << [
                    duration: duration,
                    data    : baos.toByteArray().encodeBase64().toString()
            ]
        }
        def json = new JsonBuilder(jsonDatagrams)
        destFile.text = json.toPrettyString()
    }
}

class MakeMcepDatagrams extends DefaultTask {

    final WorkerExecutor workerExecutor

    @Input
    Property<Integer> sampleRate = project.objects.property(Integer)

    @InputFile
    final RegularFileProperty basenamesFile = newInputFile()

    @InputDirectory
    final DirectoryProperty mcepDir = newInputDirectory()

    @OutputDirectory
    final DirectoryProperty destDir = newOutputDirectory()

    @Inject
    MakeMcepDatagrams(WorkerExecutor workerExecutor) {
        this.workerExecutor = workerExecutor
    }

    @TaskAction
    void make() {
        basenamesFile.get().asFile.eachLine('UTF-8') { basename ->
            def mcepFile = mcepDir.file("${basename}.mcep").get().asFile
            def destFile = destDir.file("${basename}.json").get().asFile
            workerExecutor.submit(McepDatagramMaker.class) { config ->
                config.params mcepFile, destFile, sampleRate.get()
            }
        }
    }

}

class McepDatagramMaker implements Runnable {

    File mcepFile

    File destFile

    int sampleRate

    @Inject
    McepDatagramMaker(File mcepFile, File destFile, int sampleRate) {
        this.mcepFile = mcepFile
        this.destFile = destFile
        this.sampleRate = sampleRate
    }

    @Override
    void run() {
        def mcep = new ESTTrackReader(mcepFile.path)
        def jsonDatagrams = []
        int frameStart
        int frameEnd = 0
        mcep.frames.eachWithIndex { frame, f ->
            frameStart = frameEnd
            def time = mcep.getTime(f)
            frameEnd = (time * sampleRate) as int
            def duration = frameEnd - frameStart
            jsonDatagrams << [
                    duration: duration,
                    coeffs  : frame
            ]
        }
        def json = new JsonBuilder(jsonDatagrams)
        destFile.text = json.toPrettyString()
    }
}

class TimelineMaker extends DefaultTask {

    @Input
    Property<Integer> sampleRate = project.objects.property(Integer)

    @Input
    Property<BigDecimal> idxIntervalInSeconds = project.objects.property(BigDecimal)

    @InputFile
    final RegularFileProperty basenamesFile = newInputFile()

    @InputDirectory
    final DirectoryProperty srcDir = newInputDirectory()

    @OutputFile
    final RegularFileProperty destFile = newOutputFile()

    @TaskAction
    void make() {
        def timeline = new TimelineWriter(destFile.get().asFile.path, '\n', sampleRate.get(), idxIntervalInSeconds.get());
        basenamesFile.get().asFile.eachLine('UTF-8') { basename ->
            def datagramFile = srcDir.file("${basename}.json").get().asFile
            def json = new JsonSlurper().parse(datagramFile)
            json.each { jsonDatagram ->
                def datagram = new Datagram(jsonDatagram.duration, jsonDatagram.data.decodeBase64())
                timeline.feed(datagram, sampleRate.get())
            }
        }
        timeline.close()
    }
}

class GenerateMcepTimelineHeader extends DefaultTask {

    @InputDirectory
    final DirectoryProperty srcDir = newInputDirectory()

    @OutputFile
    final RegularFileProperty destFile = newOutputFile()

    @TaskAction
    void generate() {
        // get order, range of values from EST MCEP files
        def mcepOrder
        def mcepMin
        def mcepMax
        project.fileTree(srcDir).include('*.mcep').each { mcepFile ->
            def mcep = new ESTTrackReader(mcepFile.path)
            mcepOrder = mcep.numChannels
            def minMax = mcep.minMax
            if (!mcepMin || mcepMin > minMax[0]) {
                mcepMin = minMax[0]
            }
            if (!mcepMax || mcepMax < minMax[1]) {
                mcepMax = minMax[1]
            }
        }
        assert mcepOrder
        def mcepRange = (mcepMax - mcepMin) as float
        // init header
        def cmd = '\n$ESTDIR/bin/sig2fv -window_type hamming -factor 2.5 -otype est_binary -coefs melcep -melcep_order 12' +
                ' -fbank_order 24 -shift 0.01 -preemph 0.97 -pm PITCHMARKFILE.pm -o melcepDir/mcepFile.mcep WAVDIR/WAVFILE.wav\n'
        def props = new Properties()
        props << [
                command     : cmd,
                'mcep.order': mcepOrder as String,
                'mcep.min'  : mcepMin as String,
                'mcep.range': mcepRange as String
        ]
        props.store(destFile.get().asFile.newOutputStream(), '')
    }
}

class McepTimelineMaker extends TimelineMaker {

    @InputFile
    final RegularFileProperty headerFile = newInputFile()

    @Override
    @TaskAction
    void make() {
        def props = new Properties()
        props.load(headerFile.get().asFile.newInputStream())
        def header = new ByteArrayOutputStream()
        props.store(header, '')
        def timeline = new TimelineWriter(destFile.get().asFile.path, header.toString('latin1'), sampleRate.get(), idxIntervalInSeconds.get());
        basenamesFile.get().asFile.eachLine('UTF-8') { basename ->
            def datagramFile = srcDir.file("${basename}.json").get().asFile
            def json = new JsonSlurper().parse(datagramFile)
            json.each { jsonDatagram ->
                def datagram = new MCepDatagram(jsonDatagram.duration, jsonDatagram.coeffs as float[])
                timeline.feed(datagram, sampleRate.get())
            }
        }
        timeline.close()
    }
}
